---
title: "Data Types"
slug: Configuration/data-types
lang: en
game: java
version: "1.21.6"
description: Minecraft Java 1.21.6 Data Types
---

<Note type='info'>
  **⚠️ Endianness Reminder:** All multi-byte fields (except `VarInt` and `VarLong`) use **big-endian**. If you’re on a little-endian system (common on x86), swap your bytes before sending!
</Note>

<Tabs defaultValue="primitive" orientation="vertical">
  <TabsList>
    <Tab value="primitive">Primitive Integers</Tab>
    <Tab value="floating">Floating-Point</Tab>
    <Tab value="varint">Variable-Length</Tab>
    <Tab value="string">Strings & Text</Tab>
    <Tab value="misc">Misc Types</Tab>
    <Tab value="collections">Collections</Tab>
    <Tab value="others">Other Structures</Tab>
  </TabsList>

  {/* ---------- Primitive ---------- */}
  <TabsContent value="primitive">
    <Step>
      <StepTitle>What are Primitive Integers?</StepTitle>
      <StepContent>
        Fixed-size integer types represent values with a constant number of bytes. They are the simplest building blocks for most packet fields.
      </StepContent>
    </Step>
    <Step isLast="true">
      <StepTitle>Why Endianness Matters</StepTitle>
      <StepContent>
        Big-endian means the most significant byte is sent first. When writing on a little-endian system, use Buffer methods like `writeInt32BE`.
      </StepContent>
    </Step>
    </br>
    
    | Name              | Bytes | Range                                  | Use Case Example                                     |
    | ----------------- | ----- | -------------------------------------- | ---------------------------------------------------- |
    | **Boolean**       | 1     | `false` (0x00), `true` (0x01)        | Toggle flags like “on ground” in movement packets    |
    | **Byte**          | 1     | –128 to 127                          | Small signed values (e.g., pitch angles)             |
    | **Unsigned Byte** | 1     | 0 to 255                             | Particle data, block IDs in older versions           |
    | **Short**         | 2     | –32 768 to 32 767                    | Y-coordinate in Position (legacy)                   |
    | **Unsigned Short**| 2     | 0 to 65 535                          | Port numbers in Handshake packet                    |
    | **Int**           | 4     | –2 147 483 648 to 2 147 483 647       | Entity IDs, chunk coordinates                       |
    | **Long**          | 8     | –9 223 372 036 854 775 808 to …      | UUID segments, timestamps                           |
  </TabsContent>

  {/* ---------- Floating ---------- */}
  <TabsContent value="floating">
    <p>Floating-point numbers allow for fractional values—crucial for positions, velocities, and rotations in 3D space.</p>
    | Name      | Bytes | Precision                            | Example                                              |
    | --------- | ----- | ------------------------------------ | ---------------------------------------------------- |
    | **Float** | 4     | 32-bit, ~7 decimal digits            | Player movement X/Y/Z coordinates                    |
    | **Double**| 8     | 64-bit, ~16 decimal digits           | Sub-block precision (e.g., horse positions)          |

    <Preview title="Float Example">
      <CustomSyntaxHighlighter
        tabs={{
          js: { language: 'javascript', syntax: `// Write a 32-bit float (big-endian)
const buf = Buffer.alloc(4);
buf.writeFloatBE(3.14);

// Read back:
const f = buf.readFloatBE(0);
console.log(f); // 3.14` }
        }}
        themeMode="dark"
        indicatorColor="bg-blue-900"
      />
    </Preview>
  </TabsContent>

  {/* ---------- VarInt ---------- */}
  <TabsContent value="varint">
    <p>`VarInt` and `VarLong` pack integers into 7 bits per byte, setting the highest bit as a continuation flag. This makes small values only cost 1 byte.</p>
    | Name       | Bytes      | Encodes                        | How It Works                                          |
    | ---------- | ---------- | ------------------------------ | ----------------------------------------------------- |
    | **VarInt** | 1–5        | 32-bit signed integer         | Read 7 bits, if MSB=1 continue, repeat                |
    | **VarLong**| 1–10       | 64-bit signed integer         | Same pattern but up to 10 bytes                       |

    <Button onClick={() => alert('Step-by-step decoding sequence...')}>
      Show decoding steps
    </Button>
  </TabsContent>

  {/* ---------- String ---------- */}
  <TabsContent value="string">
    <p>Text fields are length-prefixed UTF-8. The length prefix is always a `VarInt`, counting UTF-16 code units (not bytes!).</p>
    | Name                    | Prefix    | Encoding               | Limits                                                |
    | ----------------------- | --------- | ---------------------- | ----------------------------------------------------- |
    | **String(n)**           | VarInt    | UTF-8                  | Max `n` UTF-16 units, typically 32 767                |
    | **Identifier**          | VarInt    | UTF-8                  | Resource names, limited to alphanumeric, `_`, `:`     |
    | **Text Component**      | NBT Tag   | JSON/NBT               | Rich chat messages, hover text, clickable links       |
    
    <Note>
      Always ensure your JSON text matches the schema: `{ "text": "..." }`, with extra fields for formatting.
    </Note>
  </TabsContent>

  {/* ---------- Miscellaneous ---------- */}
  <TabsContent value="misc">
    <p>Special fixed-size structures used across packets:</p>
    | Name      | Bytes | Description                                        |
    | --------- | ----- | -------------------------------------------------- |
    | **Position** | 8  | Encodes block coordinates: x(26 bits), z(26 bits), y(12 bits) |
    | **Angle**    | 1  | One byte per 1/256 turn (0–255)                   |
    | **UUID**     | 16 | 128-bit identifier (two 64-bit values MSB then LSB)|
  </TabsContent>

  {/* ---------- Collections ---------- */}
  <TabsContent value="collections">
    <p>Containers and optional fields let you combine or conditionally include data:</p>
    | Name                  | Prefix             | Contents                                           |
    | --------------------- | ------------------ | -------------------------------------------------- |
    | **Optional X**        | Contextual         | Field omitted or present                           |
    | **Prefixed Optional** | Boolean + X        | Eg: enchantment levels                             |
    | **Array of X**        | Contextual length  | Sequence of elements                               |
    | **Prefixed Array**    | VarInt + data      | E.g., list of block states in a chunk              |
    | **EnumSet (n)**       | ⌈n/8⌉ bytes        | Bitset representing enum flags                     |
  </TabsContent>

  {/* ---------- Other Structures ---------- */}
  <TabsContent value="others">
    <p>Some packet fields use bespoke formats. Check the protocol spec for details:</p>
    - **Sound Event** (varies) – event ID + optional data  
    - **Chat Type** (varies) – direct vs system messages  
    - **Teleport Flags** (4 bytes) – mask for x/y/z relative flags  
    - **Chunk Data** (varies) – compressed region data    
    - **Light Data** (varies) – sky and block light arrays
  </TabsContent>
</Tabs>
